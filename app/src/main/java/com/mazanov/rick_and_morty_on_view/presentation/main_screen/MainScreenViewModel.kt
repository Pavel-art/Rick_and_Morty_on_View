package com.mazanov.rick_and_morty_on_view.presentation.main_screenimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport androidx.paging.*import com.mazanov.rick_and_morty_on_view.data.remote_data_source.repository_impl.RickMortyPagingSourceimport com.mazanov.rick_and_morty_on_view.data.remote_data_source.retrofit.ApiServiceimport com.mazanov.rick_and_morty_on_view.domain.models.PersonModelimport com.mazanov.rick_and_morty_on_view.domain.useCases.GetAllCharactersUseCaseimport dagger.hilt.android.lifecycle.HiltViewModelimport kotlinx.coroutines.flow.*import javax.inject.Inject@HiltViewModelclass MainScreenViewModel @Inject constructor(    private var getAllCharactersUseCase: GetAllCharactersUseCase,    private val apiService: ApiService) : ViewModel() {    private var _state = MutableLiveData<MainScreenState>(MainScreenState.Initial)    val state: LiveData<MainScreenState> = _state    init {        loadPersons()    }    private fun loadPersons() {        try {            getAllCharactersUseCase.invoke()                .onStart { _state.value = MainScreenState.Loading }                .filter { it.isNotEmpty() }                .onEach { _state.value = MainScreenState.Load(content = it) }                .launchIn(viewModelScope)        } catch (e: Exception) {            _state.value = MainScreenState.Error(error = e.message.toString())        }    }    val listData: Flow<PagingData<PersonModel>> = Pager(        PagingConfig(            pageSize = 1,            enablePlaceholders = true        )    ) {        RickMortyPagingSource()    }.flow.catch { error -> _state.value = MainScreenState.Error(error.toString()) }        .cachedIn(viewModelScope)}